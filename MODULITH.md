# üåü Spring Modulith ‚Äî Guide d‚ÄôArchitecture (v2)

> **Contexte projet** : monolithe modulaire Spring pour *candidat*, *candidature*, *recruteur* + un module *shared* (√©v√©nements).
> **Objectif** : poser des fronti√®res claires, rendre les d√©pendances explicites, documenter et tester l‚Äôarchitecture.

---

## 1) Pourquoi Spring Modulith (ici) ?


| Besoin                         | Multi‚Äëmodule Maven     | Microservices    | **Spring Modulith**                  |
| ------------------------------ | ----------------------- | ---------------- | ------------------------------------ |
| Fronti√®res explicites         | Faibles (compile‚Äëtime) | Fortes (r√©seau) | **Fortes (runtime + v√©rification)** |
| Co√ªt d‚Äôexploitation          | Bas                     | √âlev√©          | **Bas**                              |
| Refactorisation d‚Äôun existant | Lourde                  | Tr√®s lourde     | **Progressive**                      |
| Documentation int√©gr√©e       | Non                     | Non              | **Oui (Documenter + AsciiDoc)**      |

Modulith nous donne la **discipline d‚Äôun microservice** (contrats, limites, √©v√©nements) **sans** la complexit√© d‚Äôexploitation.

---

## 2) Fronti√®res & nommage : r√®gles du jeu

- Chaque **sous‚Äëpackage racine** de `com.accenture.modules` est un **module** :
  `candidat`, `candidature`, `recruteur`, `shared`.
- Par d√©faut, **tout est priv√© au module**.
  Pour exposer un contrat, on **annote le package** avec `@NamedInterface` (dans `package-info.java`).

### 2.1. Deux *types* d‚ÄôAPI d‚Äôentr√©e (distinction cl√©)

> Un m√™me service peut impl√©menter **deux interfaces** diff√©rentes ‚Äî une pour le REST (interne), l‚Äôautre pour les autres modules (publique).


| API                         | But                                     | Visible par d‚Äôautres modules ? | O√π ?                | Annotation                         |
| --------------------------- | --------------------------------------- | ------------------------------- | -------------------- | ---------------------------------- |
| **UseCase (REST)**          | Contrat utilis√© par le**controller**   | Non                             | `...service.usecase` | üö´*(pas de @NamedInterface)*       |
| **Gateway (inter‚Äëmodule)** | Contrat utilis√© par**un autre module** | Oui                             | `...service.gateway` | ‚úÖ`@NamedInterface("xxx.gateway")` |

**Exemple** (*module `recruteur`*) :

```java
// recruteur/service/usecase/OfferServiceUseCase.java
public interface OfferServiceUseCase {
    Offer create(String title, String description);
    List<Offer> all();
}

// recruteur/service/gateway/OfferServiceGateway.java
public interface OfferServiceGateway {
    boolean exists(UUID offerId);
}
```

`package-info.java` (gateway) :

```java
@org.springframework.modulith.NamedInterface("offer.gateway")
package com.accenture.modules.recruteur.service.gateway;
```

**Impl√©mentation unique** (mutualisation m√©tier) :

```java
@Service
@Transactional
@RequiredArgsConstructor
public class OfferService implements OfferServiceUseCase, OfferServiceGateway {
    private final OfferRepository repo;
    private final OfferEntityMapper mapper;
    // ...
}
```

### 2.2. Organisation type d‚Äôun module

```
recruteur/
 ‚îú‚îÄ repository/           # Adaptateurs de persistance (Spring Data JPA)
 ‚îÇ   ‚îú‚îÄ entity/           # Entit√©s JPA (priv√©es au module)
 ‚îÇ   ‚îî‚îÄ mapper/           # MapStruct Entity <-> Domaine
 ‚îú‚îÄ service/
 ‚îÇ   ‚îú‚îÄ domain/           # Mod√®le m√©tier pur (POJOs, aucune d√©pendance Spring)
 ‚îÇ   ‚îú‚îÄ usecase/          # Interfaces pour les controllers REST (internes)
 ‚îÇ   ‚îú‚îÄ gateway/          # Interfaces inter‚Äëmodules (expos√©es)
 ‚îÇ   ‚îî‚îÄ listener/         # R√©actions aux √©v√©nements (post‚Äëcommit)
 ‚îî‚îÄ web/                  # REST (DTO, mapper, controller) ‚Äì interne
```

> **Ne jamais** r√©f√©rencer depuis un autre module : `repository`, `web`, `service.domain`, `service.listener`, **ni** les *mappers* internes.

---

## 3) Communication inter‚Äëmodules : √©v√©nements & contrats

### 3.1. Contrats synchrones (Gateway)

- **√Ä utiliser** quand tu as besoin d‚Äôune **r√©ponse imm√©diate** (ex: valider l‚Äôexistence d‚Äôune offre).
- Exemple (dans `candidature`) :

```java
@RequiredArgsConstructor
@Service
public class CandidatureService {
    private final OfferServiceGateway offers; // üëà d√©pend d‚Äôun contrat public

    public void create(UUID offerId, UUID candidatId) {
        if (!offers.exists(offerId)) throw new IllegalArgumentException("Offre inconnue");
        // ...
    }
}
```

### 3.2. Contrats asynchrones (√âv√©nements de domaine)

- **√Ä utiliser** pour propager un changement **sans couplage temporel**.
- Les √©v√©nements sont **post‚Äëcommit** et peuvent √™tre **persist√©s** (table `event_publication`) gr√¢ce √† `spring-modulith-events-jpa`.

**Emetteur** (dans `candidature`) :

```java
events.publishEvent(new CandidatureCreatedEvent(saved.getId(), saved.getCandidateId(), saved.getOfferId(), saved.getCreatedAt()));
```

**Listener** (dans `recruteur`) :

```java
@Component
@RequiredArgsConstructor
public class CandidatureEventsListener {

    private final OfferRepository repo;

    @ApplicationModuleListener // üëà enregistre la d√©pendance inter‚Äëmodule
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    void onCandidatureCreated(CandidatureCreatedEvent evt) {
        repo.findById(evt.offerId()).ifPresent(offer -> {
            offer.setNbCandidatures(offer.getNbCandidatures() + 1);
            repo.save(offer);
        });
    }
}
```

**√âv√©nement partag√©** (module `shared`) :

```java
// shared/events/CandidatureCreatedEvent.java
public record CandidatureCreatedEvent(UUID id, UUID candidateId, UUID offerId, Instant createdAt) {}
```

`package-info.java` :

```java
@org.springframework.modulith.NamedInterface("event")
package com.accenture.modules.shared.events;
```

> üìù Avec `events-jpa`, tu verras dans les logs : *Registering publication‚Ä¶* puis *Marking publication‚Ä¶ completed* apr√®s traitement.

---

## 4) Ce que nous avons corrig√© (pi√®ges r√©els rencontr√©s)

1. **Cycle de d√©pendance** `candidature ‚Üî recruteur`
   ‚ûú caus√© par l‚Äôusage d‚Äôun *mapper interne* d‚Äôun autre module.
   ‚úÖ **Fix** : ne d√©pendre que d‚Äôinterfaces expos√©es (`gateway`) ou d‚Äô√©v√©nements.
2. **√âv√©nement non re√ßu** malgr√© `publishEvent`
   ‚ûú le type de l‚Äô√©v√©nement n‚Äô√©tait pas **expos√©** (`@NamedInterface`) ou n‚Äô√©tait pas **dans le module partag√©**.
   ‚úÖ **Fix** : d√©placer l‚Äô√©v√©nement dans `shared.events` annot√©, et utiliser `@ApplicationModuleListener`.
3. **Conflit de bean `CandidatureEventsListener`**
   ‚ûú deux classes avec le m√™me simple name dans deux modules.
   ‚úÖ **Fix** : nommage distinct et/ou un seul listener par responsabilit√©, package clair.
4. **Confusion ‚ÄúUseCase vs Gateway‚Äù**
   ‚ûú les autres modules appelaient des interfaces destin√©es aux controllers REST.
   ‚úÖ **Fix** : s√©parer `service.usecase` (interne) et `service.gateway` (public) + dual‚Äëimpl√©mentation.

---

## 5) Documentation & validation d‚Äôarchitecture

### 5.1. V√©rifier la modularit√© (test)

```java
@SpringBootTest
class ModularityTest {
    @Test
    void verify() {
        ApplicationModules modules = ApplicationModules.of(SpringModulithApplication.class);
        modules.verify(); // cycles, acc√®s non expos√©s, etc.
    }
}
```

### 5.2. G√©n√©rer la doc des modules

Dans un test d√©di√© :

```java
@SpringBootTest
class ModularityDocumentationTest {
    @Test
    void generateDocs() {
        ApplicationModules modules = ApplicationModules.of(SpringModulithApplication.class);
        new Documenter(modules).writeDocumentation(); // gen AsciiDoc + PlantUML
    }
}
```

Les fichiers sont g√©n√©r√©s dans : `target/spring-modulith-docs/`
(*ex. `module-recruteur.adoc`, `components.puml`, `all-docs.adoc`, ‚Ä¶*)

### 5.3. Transformer en HTML (Asciidoctor **exactement** comme dans le projet)

```xml
<plugin>
  <groupId>org.asciidoctor</groupId>
  <artifactId>asciidoctor-maven-plugin</artifactId>
  <version>3.0.0</version>
  <executions>
    <execution>
      <id>generate-html-docs</id>
      <phase>verify</phase>
      <goals>
        <goal>process-asciidoc</goal>
      </goals>
      <configuration>
        <sourceDirectory>${project.build.directory}/spring-modulith-docs</sourceDirectory>
        <outputDirectory>${project.build.directory}/spring-modulith-docs/html</outputDirectory>
        <backend>html5</backend>
        <attributes>
          <toc>left</toc>
          <sectnums>true</sectnums>
          <source-highlighter>coderay</source-highlighter>
          <toclevels>3</toclevels>
          <icons>font</icons>
        </attributes>
      </configuration>
    </execution>
  </executions>
</plugin>
```

‚û°Ô∏è R√©sultat : `target/spring-modulith-docs/html/index.html`

---

## 6) Conventions & check‚Äëlist

### 6.1. Nommage & packages

- `service.usecase` ‚Üí **UseCase** (REST, interne)
- `service.gateway` ‚Üí **Gateway** (inter‚Äëmodule, public via `@NamedInterface`)
- `service.domain` ‚Üí **POJOs** m√©tier (aucun import Spring/JPA)
- `service.listener` ‚Üí **@ApplicationModuleListener** (post‚Äëcommit)
- `repository.entity` / `repository.mapper` ‚Üí **priv√©s au module**
- `web.dto` / `web.mapper` / `web.*Controller` ‚Üí **strictement internes**

### 6.2. Principes

- **Jamais** de d√©pendance vers un package non expos√© d‚Äôun autre module.
- **Pr√©f√©rer** les √©v√©nements pour les r√©actions *√† posteriori*.
- **Dual interface** : un service peut impl√©menter *UseCase* **et** *Gateway*.
- **DTOs REST ‚â† objets domaine** : mapper explicitement.
- **Transactions courtes** ; listener avec `REQUIRES_NEW` si n√©cessaire.

### 6.3. Commandes utiles

```bash
# Build + tests + g√©n√©ration de la doc AsciiDoc puis HTML
./mvnw clean verify

# Lancer l‚Äôapp
./mvnw spring-boot:run
```

---

## 7) Exemple concret : module `recruteur` (extrait)

```
recruteur/
 ‚îú‚îÄ repository/entity/OfferEntity.java
 ‚îú‚îÄ repository/mapper/OfferEntityMapper.java
 ‚îú‚îÄ service/domain/Offer.java
 ‚îú‚îÄ service/usecase/OfferServiceUseCase.java
 ‚îú‚îÄ service/gateway/OfferServiceGateway.java   # @NamedInterface("offer.gateway")
 ‚îú‚îÄ service/listener/CandidatureEventsListener.java
 ‚îú‚îÄ service/OfferService.java                  # impl UseCase + Gateway
 ‚îî‚îÄ web/dto + web/mapper + web/OfferController.java
```

**Contrats expos√©s** : `service.gateway` (inter‚Äëmodule), `shared.events` (√©v√©nements).
**Non expos√©** : tout le reste (web, repository, domain, mappers).

---

## 8) FAQ (rapide)

- **Faut‚Äëil `@EnableModulith` ?** ‚Üí Non (1.3+).
- **Pourquoi mon listener ne logge rien ?** ‚Üí V√©rifie : type d‚Äô√©v√©nement **expos√©** + `@ApplicationModuleListener` + transaction **committ√©e**.
- **Puis‚Äëje appeler un mapper d‚Äôun autre module ?** ‚Üí Non (interne). Passe par un **Gateway** ou un **√©v√©nement**.
- **O√π vivent les √©v√©nements ?** ‚Üí Dans un module **shared.events** annot√© `@NamedInterface("event")`.

---

## 9) R√©f√©rences

- Docs : https://docs.spring.io/spring-modulith/reference/
- Samples : https://github.com/spring-projects/spring-modulith-samples

---

**Auteur** : Emmanuel Fernandez - Accenture ‚Äî Architecture Java
**Version** : 2.0 ‚Äî Oct. 2025
